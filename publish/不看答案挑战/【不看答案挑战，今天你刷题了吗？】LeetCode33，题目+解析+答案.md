
> 你是否觉得每天面对繁忙的工作和生活，编程能力逐渐停滞不前？或者你在寻找心仪工作的过程中，因为算法题目而错失良机？每次对面试官各种算法题目而力有不逮？那么从现在开始参与**【不看答案挑战，每天刷一道LeetCode题目】**

## 挑战开始

每天一道 LeetCode 题，不看答案，独立完成。这不仅仅是一个刷题的过程，更是一种锻炼思维、培养毅力和解决问题能力的方式。

**具体挑战内容如下：**

1. **每日刷题**：每天笔者为大家从 LeetCode 中选择一道新的算法题进行解答，以**【Medium】**为主
2. **不看答案**：在整个解题过程中，尽量不查看任何形式的参考答案。
3. **记录过程**：每次解题后，记录你的解题思路和遇到的挑战。
4. **持续坚持**：尽量每天坚持完成一道题目，看看你能连续几天坚持下来。
5. **总结与反思**：每周或每月对你的解题过程进行总结，反思哪些方法和技巧对你最有效，哪些需要进一步改进。
6. **分享打卡**：完成挑战的同学可以在评论区留言，笔者会为每一位完成调整的同学点赞评论留言



----

## 题目【Medium】

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。



```
示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1
```



> 大家可以开始思考如何解答了哦。没有思路的同学可以稍稍往下滑动看一下参考思路



----

## 参考思路

### 标签

- 数组
- 二分查找



### 思路

1. 首先明白，旋转数组后，从中间划分，一定有一边是有序的。
2. 由于一定有一边是有序的，所以根据有序的两个边界值来判断目标值在有序一边还是无序一边
3. 由于有序的一边的边界值可能等于目标值，所以判断目标值是否在有序的那边时应该加个等号
4. 计算目标值在那一边的时候，不能只考虑一边，而是要考虑范围



> 不要在往下滑了哦 :) 加油！

> 不要在往下滑了哦 :) 加油！

> 不要在往下滑了哦 :) 加油！



----

## 答案

```java
	public int search(int[] nums, int target) {
        // 一个是有序的，一个是无序的
        // 确定哪一个是有序，在无序中在找有序和无序
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (target == nums[mid]) {
                return mid;
            }
            // 由于有序的一边的边界值可能等于目标值，所以判断目标值是否在有序的那边时应该加个等号
            if (nums[mid] >= nums[left]) {
                // 左边有序
                if (nums[mid] > target && nums[left] <= target) {
                    // 计算目标值在那一边的时候，不能只考虑一边，而是要考虑范围
                    // target在左边
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                // 右边有序
                if (nums[mid] < target && nums[right] >= target) {
                    // target在右边
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }
```



----


## 更多惊喜

我还将定期分享：

- **最新互联网资讯**：让你时刻掌握行业动态。

- **AI前沿新闻**：紧跟技术潮流，不断提升自我。

- **技术分享与职业发展**：助你在职业生涯中走得更远、更稳。

- **程序员生活趣事**：让你在忙碌的工作之余找到共鸣与乐趣。

  

> **关注回复【1024】惊喜等你来拿！**

[点击查看惊喜](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/image-20240624140818030_937cf7d78178894d03f37dfb3b640b8a.png)

## 敬请关注【程序员世杰】

[点击关注程序员世杰](https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/2024/coder_world_618-9122505_324d5d2e80e9ad51355871aa6ebda8f0.jpg)

